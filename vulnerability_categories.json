{
  "categories": {
    "denial_of_servicedos_attack": {
      "description": "Attackers overload a system, making it unavailable to legitimate users, often by exploiting design vulnerabilities or resource limitations.",
      "examples": [
        "Is the withdrawal pattern followed to prevent denial of service?",
        "Is there a minimum transaction amount enforced?",
        "How does the protocol handle tokens with blacklisting functionality?",
        "Can forcing the protocol to process a queue lead to DOS?",
        "What happens with low decimal tokens that might cause DOS?"
      ],
      "common_patterns": [
        "Implement logic to handle low decimal tokens in a way that prevents the transaction process from bre",
        "Disallow transactions below a certain threshold to maintain efficiency and prevent denial of service",
        "Account for the possibility of blacklisting within token protocols to ensure continued functionality",
        "Implement withdrawal pattern best practices to ensure that contract behavior remains predictable and"
      ],
      "detection_strategy": "Attackers overload a system, making it unavailable to legitimate users, often by exploiting design v... Verify proper handling of these scenarios.",
      "main_category": "Attacker's Mindset",
      "num_checklist_items": 6
    },
    "donation_attack": {
      "description": "An attacker sends some amount of cryptocurrency to a contract and makes the protocol accounting reaches to an unexpected state.",
      "examples": [
        "Does the protocol rely on `balance` or `balanceOf` instead of internal accounting?"
      ],
      "common_patterns": [
        "Implement internal accounting instead of relying on `balanceOf` natively."
      ],
      "detection_strategy": "An attacker sends some amount of cryptocurrency to a contract and makes the protocol accounting reac... Verify proper handling of these scenarios.",
      "main_category": "Attacker's Mindset",
      "num_checklist_items": 1
    },
    "front_running_attack": {
      "description": "Attackers watch pending transactions and then push their own transaction with a higher gas fee, ensuring it's executed before the targeted transaction.",
      "examples": [
        "Are \"get-or-create\" patterns protected against front-running attacks?",
        "Are two-transaction actions designed to be safe from frontrunning?",
        "Can users maliciously cause others' transactions to revert by preempting with dust?",
        "Is the protocol using a properly user-bound commit-reveal scheme?"
      ],
      "common_patterns": [
        "Implement checks to prevent transactions with non-material amounts from affecting the contract's sta",
        "Separate creation and interaction into distinct transactions or implement robust protections (parame",
        "Implement a two-phase process where users first commit a hash containing their address and all trans",
        "Ensure critical actions that are split across multiple transactions cannot be interfered with by att"
      ],
      "detection_strategy": "Attackers watch pending transactions and then push their own transaction with a higher gas fee, ensu... Verify proper handling of these scenarios.",
      "main_category": "Attacker's Mindset",
      "num_checklist_items": 4
    },
    "griefing_attack": {
      "description": "Malicious actors intentionally cause harm to a system, often without direct profit for themselves, just to disrupt its operations or users.",
      "examples": [
        "Is there an external function that relies on states that can be changed by others?",
        "Can the contract operations be manipulated with precise gas limit specifications?"
      ],
      "common_patterns": [
        "Implement explicit gas checks before critical operations.",
        "Ensure normal user actions especially important actions like withdrawal and repayment are not distur"
      ],
      "detection_strategy": "Malicious actors intentionally cause harm to a system, often without direct profit for themselves, j... Verify proper handling of these scenarios.",
      "main_category": "Attacker's Mindset",
      "num_checklist_items": 2
    },
    "miner_attack": {
      "description": "Miners, who validate and add transactions to the blockchain, manipulate block attributes like hash or timestamp to influence contract execution or outcomes.",
      "examples": [
        "Is block.timestamp used for time-sensitive operations?",
        "Is the contract using block properties like timestamp or difficulty for randomness generation?",
        "Is contract logic sensitive to transaction ordering?"
      ],
      "common_patterns": [
        "Implement protection by allowing users to specify acceptable results that revert transactions when b",
        "Use block.number instead of timestamps for critical timing operations or ensure manipulation toleran",
        "Use a secure randomness source like Chainlink VRF, commit-reveal schemes, or a provably fair randomi"
      ],
      "detection_strategy": "Miners, who validate and add transactions to the blockchain, manipulate block attributes like hash o... Verify proper handling of these scenarios.",
      "main_category": "Attacker's Mindset",
      "num_checklist_items": 3
    },
    "price_manipulation_attack": {
      "description": "Malicious actors intentionally alter the price of assets on decentralized exchanges, usually to exploit dependent contracts or trades.",
      "examples": [
        "Is the price calculated by the ratio of token balances?",
        "Is the price calculated from DEX liquidity pool spot prices?"
      ],
      "common_patterns": [
        "Use the Chainlink oracles for the asset prices.",
        "Use TWAP (time-weighted average price) with appropriate time windows based on asset volatility and l"
      ],
      "detection_strategy": "Malicious actors intentionally alter the price of assets on decentralized exchanges, usually to expl... Verify proper handling of these scenarios.",
      "main_category": "Attacker's Mindset",
      "num_checklist_items": 2
    },
    "reentrancy_attack": {
      "description": "An attacker exploits a contract's logic to repeatedly call into a function before the previous invocation is complete, potentially draining funds.",
      "examples": [
        "Is there a view function that can return a stale value during interactions?",
        "Is there any state change after interaction to an external contract?"
      ],
      "common_patterns": [
        "Extend the reentrancy guard to the view functions as well.",
        "Use check-effects-interactions pattern or reentrancy guards."
      ],
      "detection_strategy": "An attacker exploits a contract's logic to repeatedly call into a function before the previous invoc... Verify proper handling of these scenarios.",
      "main_category": "Attacker's Mindset",
      "num_checklist_items": 2
    },
    "replay_attack": {
      "description": "Attackers resend or duplicate valid data/signature transmissions to deceive or impersonate another entity.",
      "examples": [
        "Are there protections against replay attacks for failed transactions?",
        "Is there protection against replaying signatures on different chains?"
      ],
      "common_patterns": [
        "Implement nonce-based or other mechanisms to ensure that each transaction can only be executed once,",
        "Use chain-specific parameters or domain separators to ensure signatures are only valid on the intend"
      ],
      "detection_strategy": "Attackers resend or duplicate valid data/signature transmissions to deceive or impersonate another e... Verify proper handling of these scenarios.",
      "main_category": "Attacker's Mindset",
      "num_checklist_items": 2
    },
    "rug_pull": {
      "description": "Developers or initial project backers abruptly withdraw their funds from a decentralized project or application, often leaving other investors at a loss.",
      "examples": [
        "Can the admin of the protocol pull assets from the protocol?"
      ],
      "common_patterns": [
        "Allow access to only the relevant parts of protocol funds, e.g. by tracking fees internally. Forcing"
      ],
      "detection_strategy": "Developers or initial project backers abruptly withdraw their funds from a decentralized project or ... Verify proper handling of these scenarios.",
      "main_category": "Attacker's Mindset",
      "num_checklist_items": 1
    },
    "sandwich_attack": {
      "description": "Malicious actors identify a target transaction on the blockchain, and place their own before and after it, capitalizing on potentially advantageous order execution.",
      "examples": [
        "Does the protocol have an explicit slippage protection on user interactions?"
      ],
      "common_patterns": [
        "Allow users to specify the minimum output amount and revert the transaction if it is not satisfied."
      ],
      "detection_strategy": "Malicious actors identify a target transaction on the blockchain, and place their own before and aft... Verify proper handling of these scenarios.",
      "main_category": "Attacker's Mindset",
      "num_checklist_items": 1
    },
    "sybil_attack": {
      "description": "A single adversary controls multiple nodes in a network, primarily to subvert its functionality or to gather more than their fair share of resources.",
      "examples": [
        "Is there a mechanism depending on the number of users?"
      ],
      "common_patterns": [
        "Do not rely on the number of users in quorum design."
      ],
      "detection_strategy": "A single adversary controls multiple nodes in a network, primarily to subvert its functionality or t... Verify proper handling of these scenarios.",
      "main_category": "Attacker's Mindset",
      "num_checklist_items": 1
    },
    "access_control": {
      "description": "Vulnerabilities related to access control.",
      "examples": [
        "Did you clarify all the actors and their allowed interactions in the protocol?",
        "Are there functions lacking proper access controls?",
        "Do certain addresses require whitelisting?",
        "Does the protocol allow transfer of privileges?",
        "What happens during the transfer of privileges?"
      ],
      "common_patterns": [
        "List down all the actors and interactions and draw a diagram.",
        "Double check how the protocol works during the transfer of privileges.",
        "Implement and rigorously test access controls like `onlyOwner` or role-based permissions to ensure o",
        "Make sure you know the difference of `tx.origin` and `msg.sender` and use properly."
      ],
      "detection_strategy": "Vulnerabilities related to access control.... Verify proper handling of these scenarios.",
      "main_category": "Basics",
      "num_checklist_items": 7
    },
    "array_loop": {
      "description": "Issues related to Array / Loop",
      "examples": [
        "What happens on the first and the last cycle of the iteration?",
        "How does the protocol remove an item from an array?",
        "Does any function get an index of an array as an argument?",
        "Is the summing of variables done accurately compared to separate calculations?",
        "Is it fine to have duplicate items in the array?"
      ],
      "common_patterns": [
        "Copy the last element to the index of the element to be removed and decrease the length of an array.",
        "Ensure a failure of a single iteration does not revert the whole operation.",
        "Ensure the logic is correct for the first and the last cycles.",
        "Add a validation to check the array is unique."
      ],
      "detection_strategy": "Check for issues related to array / loop.",
      "main_category": "Basics",
      "num_checklist_items": 11
    },
    "block_reorganization": {
      "description": "A chain reorganization, or \u201creorg,\u201d happens when validators disagree on the most accurate version of the blockchain. Reorgs occurs when multiple blocks happen to be produced at the same time, if there is a bug, or due to a malicious attack.",
      "examples": [
        "Does the protocol implement a factory pattern using the CREATE opcode?"
      ],
      "common_patterns": [
        "Use CREATE2 instead of CREATE."
      ],
      "detection_strategy": "A chain reorganization, or \u201creorg,\u201d happens when validators disagree on the most accurate version of... Verify proper handling of these scenarios.",
      "main_category": "Basics",
      "num_checklist_items": 1
    },
    "event": {
      "description": "Issues related to Event",
      "examples": [
        "Does the protocol emit events on important state changes?"
      ],
      "common_patterns": [
        "Ensure to emit events in all important functions."
      ],
      "detection_strategy": "Check for issues related to event.",
      "main_category": "Basics",
      "num_checklist_items": 1
    },
    "function": {
      "description": "Issues related to Function",
      "examples": [
        "Are the inputs validated?",
        "Are the outputs validated?",
        "Can the function be front-run?",
        "Are the code comments coherent with the implementation?",
        "Can edge case inputs (0, max) result in unexpected behavior?"
      ],
      "common_patterns": [
        "Ensure thorough validation. E.g. min/max for numeric values, start/end for dates, ownership of posit",
        "Limit function visibility to the strictest level possible (`private` or `internal`).",
        "Make sure the function works as expected for the edge values.",
        "Make sure there is no unexpected risk even if attackers front-run."
      ],
      "detection_strategy": "Check for issues related to function.",
      "main_category": "Basics",
      "num_checklist_items": 9
    },
    "inheritance": {
      "description": "Issues related to Inheritance",
      "examples": [
        "Is it necessary to limit visibility of parent contract's public functions?",
        "Were all necessary functions implemented to fulfill inheritance purpose?",
        "Has the contract implemented an interface?",
        "Does the inheritance order matter?"
      ],
      "common_patterns": [
        "Make sure to expose only relevant functions from parent contracts.",
        "Verify the inheritance chain is ordered from 'most base-like' to 'most derived' to prevent issues li",
        "Make sure to implement all functions specified in the interface.",
        "Make sure to expose relevant functions from parent contracts."
      ],
      "detection_strategy": "Check for issues related to inheritance.",
      "main_category": "Basics",
      "num_checklist_items": 4
    },
    "initialization": {
      "description": "Issues related to Initialization",
      "examples": [
        "Are important state variables initialized properly?",
        "Has the contract inherited OpenZeppelin's Initializable?",
        "Does the contract have a separate initializer function other than a constructor?"
      ],
      "common_patterns": [
        "Make sure to initialize all state variables correctly.",
        "Make sure to use the correct modifier for the initializer function.",
        "Use the factory pattern to allow only the factory to call the initializer or ensure it is not front-"
      ],
      "detection_strategy": "Check for issues related to initialization.",
      "main_category": "Basics",
      "num_checklist_items": 3
    },
    "map": {
      "description": "Issues related to Map",
      "examples": [
        "Is there need to delete the existing item from a map?"
      ],
      "common_patterns": [
        "Always ensure that inner fields are deleted before the outer fields of the structure."
      ],
      "detection_strategy": "Check for issues related to map.",
      "main_category": "Basics",
      "num_checklist_items": 1
    },
    "math": {
      "description": "Issues related to Math",
      "examples": [
        "Is the mathematical calculation accurate?",
        "Is there any loss of precision in time calculations?",
        "Are you aware that expressions like `1 day` are cast to `uint24`, potentially causing overflows?",
        "Is there any case where dividing is done before multiplication?",
        "Does the rounding direction matter?"
      ],
      "common_patterns": [
        "Use checks to prevent variable underflows and overflows.",
        "Ensure mathematical operations in inline assembly are properly tested and verified.",
        "Always check denominators before division.",
        "To avoid loss of precision, always multiply first and then divide."
      ],
      "detection_strategy": "Check for issues related to math.",
      "main_category": "Basics",
      "num_checklist_items": 12
    },
    "payment": {
      "description": "Issues related to Payment",
      "examples": [
        "Is it possible for the receiver to revert?",
        "Does the function gets the payment amount as a parameter?",
        "Are there vulnerabilities related to force-feeding?",
        "What is the minimum deposit/withdrawal amount?",
        "How is the withdrawal handled?"
      ],
      "common_patterns": [
        "Ensure the contract behaves as expected when receiving unexpected funds.",
        "Add a threshold for the deposit/withdrawal amount.",
        "Make sure that the receiver can not deny the payment or add a backup handler with a try-catch.",
        "Make sure either no ETH remains in the contract at the end of `payable` functions or make sure there"
      ],
      "detection_strategy": "Check for issues related to payment.",
      "main_category": "Basics",
      "num_checklist_items": 7
    },
    "proxyupgradable": {
      "description": "Issues related to Proxy/Upgradable",
      "examples": [
        "Is there a constructor in the proxied contract?",
        "Is the `initializer` modifier applied to the `initialization()` function?",
        "Is the upgradable version used for initialization?",
        "Is the `authorizeUpgrade()` function properly secured in a UUPS setup?",
        "Is the contract initialized?"
      ],
      "common_patterns": [
        "Use upgradable versions of parent initializer functions.",
        "Avoid using immutable variables in upgradable contracts.",
        "Ensure proper access controls and checks are in place for the `authorizeUpgrade()` function.",
        "To prevent the implementation contract from being used, invoke the `_disableInitializers` function i"
      ],
      "detection_strategy": "Check for issues related to proxy/upgradable.",
      "main_category": "Basics",
      "num_checklist_items": 10
    },
    "type": {
      "description": "Issues related to Type",
      "examples": [
        "Is there a forced type casting?",
        "Does the protocol use time units like `days`?"
      ],
      "common_patterns": [
        "Double check the calculations including time units and ensure there is no overflow for reasonable va",
        "Avoid a forced type casting as much as possible and ensure values are in the range of type limit."
      ],
      "detection_strategy": "Check for issues related to type.",
      "main_category": "Basics",
      "num_checklist_items": 2
    },
    "version_issues": {
      "description": "Vulnerabilities related to versions.",
      "examples": [
        "",
        "",
        ""
      ],
      "common_patterns": [
        "Version Issues vulnerabilities",
        "Improper validation or handling"
      ],
      "detection_strategy": "Vulnerabilities related to versions.... Verify proper handling of these scenarios.",
      "main_category": "Basics",
      "num_checklist_items": 3
    },
    "ammswap": {
      "description": "Issues related to AMM/Swap",
      "examples": [
        "Is hardcoded slippage used?",
        "Is there a deadline protection?",
        "Is there a validation check for protocol reserves?",
        "Does the AMM utilize forked code?",
        "Are there rounding issues in product constant formulas?"
      ],
      "common_patterns": [
        "Review the differences. Utilize tools such as contract-diff.xyz to compare and identify the origin o",
        "Ensure the fee-on-transfer tokens are handled correctly if they are supposed to be supported.",
        "Allow users to specify the slippage parameter in the actual asset amount which was calculated off-ch",
        "Allow a user specify the deadline of the swap."
      ],
      "detection_strategy": "Check for issues related to amm/swap.",
      "main_category": "Defi",
      "num_checklist_items": 14
    },
    "flashloan": {
      "description": "Issues related to FlashLoan",
      "examples": [
        "Is withdraw disabled in the same block to prevent flashloan attacks?",
        "Can ERC4626 be manipulated through flashloans?"
      ],
      "common_patterns": [
        "Ensure that ERC4626-related operations have in-built protections against rapid, in-block actions tha",
        "Implement a delay or disable withdrawals within the same block where a deposit or loan action took p"
      ],
      "detection_strategy": "Check for issues related to flashloan.",
      "main_category": "Defi",
      "num_checklist_items": 2
    },
    "general": {
      "description": "Common vulnerabilities of general Defi protocols",
      "examples": [
        "Can the protocol handle ERC20 tokens with decimals other than 18?",
        "Are there unexpected rewards accruing for user deposited assets?",
        "Could direct transfers of funds introduce vulnerabilities?",
        "Could the initial deposit introduce any issues?",
        "Are the protocol token pegged to any other asset?"
      ],
      "common_patterns": [
        "Test and ensure that the first deposit initializes and sets all necessary parameters correctly.",
        "Consider implementing a revert on approval functions when an unnecessarily high allowance is set.",
        "Always check and adjust for the decimal count of the ERC20 tokens being handled.",
        "Implement the internal accounting so that it is not be affected by direct transfers."
      ],
      "detection_strategy": "Common vulnerabilities of general Defi protocols... Verify proper handling of these scenarios.",
      "main_category": "Defi",
      "num_checklist_items": 9
    },
    "lending": {
      "description": "Issues related to Lending",
      "examples": [
        "Will the liquidation process function effectively during rapid market downturns?",
        "Can a position be liquidated if the loan remains unpaid or if the collateral falls below the required threshold?",
        "Is it possible for a user to gain undue profit from self-liquidation?",
        "If token transfers or collateral additions are temporarily paused, can a user still be liquidated, even if they intend to deposit more funds?",
        "If liquidations are temporarily suspended, what are the implications when they are resumed?"
      ],
      "common_patterns": [
        "Outline clear protocols for pausing and resuming liquidations, ensuring solvency is maintained.",
        "Ensure a balanced incentive structure that motivates liquidators to address positions of all sizes.",
        "Include accrued interest in LTV calculations to maintain accurate and fair credit evaluations.",
        "Review protocol logic to allow or disallow liquidation and repaying functions collectively to avoid "
      ],
      "detection_strategy": "Check for issues related to lending.",
      "main_category": "Defi",
      "num_checklist_items": 12
    },
    "liquid_staking_derivatives": {
      "description": "Issues related to Liquid Staking Derivatives",
      "examples": [
        "Can a malicious validator front-run setting withdrawal credentials?",
        "Can the exchange rate repricing update be sandwich attacked to drain ETH from the protocol?",
        "Can re-entrancy when ETH is sent during rewards/withdrawals or when NFTs are minted via `_safeMint` (to represent pending withdrawals) be used to drain the protocol's ETH?",
        "Can an arbitrary exchange rate be set when processing queued withdrawals?",
        "Can paused states be bypassed to perform restricted actions even when they should be paused?"
      ],
      "common_patterns": [
        "Don't perform division before multiplication, be aware of rounding down to zero, rounding direction,",
        "Protocols can use invariant fuzz testing with invariants which validate that relationships between i",
        "Don't allow instant withdrawals but use a withdrawal queue and run the repricing transaction through",
        "Refactor to avoid needing to iterate over the entire operator/validator set. Alternatively only use "
      ],
      "detection_strategy": "Check for issues related to liquid staking derivatives.",
      "main_category": "Defi",
      "num_checklist_items": 9
    },
    "oracle": {
      "description": "Price oracle related vulnerabilities",
      "examples": [
        "Is the Oracle using deprecated Chainlink functions?",
        "Is the returned price validated to be non-zero?",
        "Is the price update time validated?",
        "Is there a validation to check if the rollup sequencer is running?",
        "Is the Oracle's TWAP period appropriately set?"
      ],
      "common_patterns": [
        "Choose reliable and tamper-resistant oracle sources. Avoid using spot prices from AMMs directly with",
        "Implement checks to ensure that the price returned by the oracle lies within an expected range to gu",
        "Implement a mechanism to check the heartbeat of the price feed and compare it against a predefined m",
        "Ensure the protocol is not affected in the case where oracle price updates are front-run."
      ],
      "detection_strategy": "Price oracle related vulnerabilities... Verify proper handling of these scenarios.",
      "main_category": "Defi",
      "num_checklist_items": 14
    },
    "staking": {
      "description": "Issues related to Staking",
      "examples": [
        "Can a user amplify another user's time lock duration by stacking tokens on their behalf?",
        "Can the distribution of rewards be unduly delayed or prematurely claimed?",
        "Are rewards up-to-date in all use-cases?"
      ],
      "common_patterns": [
        "Implement time controls and constraints on reward distributions to maintain the protocol's intended ",
        "Ensure the update reward function is called properly in all places where the reward is relevant.",
        "Implement strict checks and controls to prevent users from influencing the time locks of other users"
      ],
      "detection_strategy": "Check for issues related to staking.",
      "main_category": "Defi",
      "num_checklist_items": 3
    },
    "aave_compound": {
      "description": "Issues related to AAVE / Compound",
      "examples": [
        "Does the protocol use cETH token?",
        "What happens if the utilization rate is too high, and collateral cannot be retrieved?",
        "What happens if the protocol is paused?",
        "What happens if the pool becomes deprecated?",
        "What happens if assets you lend/borrow are within the same eMode category?"
      ],
      "common_patterns": [
        "Ensure a proper and tested implementation of AAVE/COMP reward claims.",
        "Ensure that the protocol works as expected when a user reaches the maximum debt.",
        "Ensure the protocol behaves as expected when the AAVE protocol is paused.",
        "Make use of `getSiloedBorrowing(address asset)` to prevent unexpected problems."
      ],
      "detection_strategy": "Check for issues related to aave / compound.",
      "main_category": "Integrations",
      "num_checklist_items": 9
    },
    "balancer": {
      "description": "Issues related to Balancer",
      "examples": [
        "Does the protocol use the Balancer's flashloan?",
        "Does the protocol use Balancer's Oracle? (getTimeWeightedAverage)",
        "Does the protocol use Balancer's Boosted Pool?",
        "Does the protocol use Balancer vault pool liquidity status for any pricing?"
      ],
      "common_patterns": [
        "Balancer pools are susceptible to manipulation of their external queries, and all integrations must ",
        "Ensure the protocol uses the correct function to get the total BPT supply in circulation.",
        "Ensure the protocol repays the fee together with the original debt on repayment in the `receiveFlash",
        "Do not use the Balancer's oracle for any pricing."
      ],
      "detection_strategy": "Check for issues related to balancer.",
      "main_category": "Integrations",
      "num_checklist_items": 4
    },
    "chainlink": {
      "description": "Issues related to Chainlink",
      "examples": [
        "",
        ""
      ],
      "common_patterns": [
        "Chainlink vulnerabilities",
        "Improper validation or handling"
      ],
      "detection_strategy": "Check for issues related to chainlink.",
      "main_category": "Integrations",
      "num_checklist_items": 2
    },
    "gnosis_safe": {
      "description": "Issues related to Gnosis Safe",
      "examples": [
        "Do your modules execute the Guard's hooks?",
        "Does the `execTransactionFromModule()` function increment the nonce?"
      ],
      "common_patterns": [
        "Ensure increase nonce inside the function `execTransactionFromModule()`.",
        "Ensure that all modules correctly execute the Guard's hooks as intended."
      ],
      "detection_strategy": "Check for issues related to gnosis safe.",
      "main_category": "Integrations",
      "num_checklist_items": 2
    },
    "layerzero": {
      "description": "Issues related to LayerZero",
      "examples": [
        "Does the `_debitFrom` function in ONFT properly validate token ownership and transfer permissions?",
        "Which type of mechanism are utilized? Blocking or non-blocking?",
        "Is gas estimated accurately for cross-chain messages?",
        "Is the `_lzSend` function correctly utilized when inheriting LzApp?",
        "Is the `ILayerZeroUserApplicationConfig` interface correctly implemented?"
      ],
      "common_patterns": [
        "Configure the applications uniquely and avoid using default settings.",
        "Ensure thorough checks and validations are performed in the `_debitFrom` function to maintain token ",
        "Evaluate the chain's history and potential vulnerabilities to determine the optimal number of confir",
        "Implement the `ILayerZeroUserApplicationConfig` interface and ensure that the `forceResumeReceive` f"
      ],
      "detection_strategy": "Check for issues related to layerzero.",
      "main_category": "Integrations",
      "num_checklist_items": 7
    },
    "lsd": {
      "description": "Issues related to LSD",
      "examples": [
        "",
        "",
        "",
        ""
      ],
      "common_patterns": [
        "LSD vulnerabilities",
        "Improper validation or handling"
      ],
      "detection_strategy": "Check for issues related to lsd.",
      "main_category": "Integrations",
      "num_checklist_items": 4
    },
    "uniswap": {
      "description": "Issues related to Uniswap",
      "examples": [
        "Is the slippage calculated on-chain?",
        "Are there refunds after swaps?",
        "Is the order of `token0` and `token1` consistent across chains?",
        "Are the pools that are being interacted with whitelisted?",
        "Is there a reliance on pool reserves?"
      ],
      "common_patterns": [
        "Implement a refund mechanism to handle failed or partially filled swaps.",
        "Allow users to specify the slippage parameter in the actual asset amount which was calculated off-ch",
        "Functions allowing users to perform uni v3 swaps should allow users to pass in the fee tier paramete",
        "Always use the Router contract to handle swaps, providing an added layer of security and standardiza"
      ],
      "detection_strategy": "Check for issues related to uniswap.",
      "main_category": "Integrations",
      "num_checklist_items": 10
    },
    "fungible_erc20": {
      "description": "Issues related to Fungible : ERC20",
      "examples": [
        "Are safe transfer functions used throughout the contract?",
        "Is there potential for a race condition for approvals?",
        "Could a difference in decimals between ERC20 tokens cause issues?",
        "Does the token implement any form of address whitelisting, blacklisting, or checks?",
        "Could the use of multiple addresses for a single token lead to complications?"
      ],
      "common_patterns": [
        "Do not rely on the token address in the accounting.",
        "Ensure the protocol is not affected when the token is paused.",
        "Avoid approval of `type(uint256).max`.",
        "Ensure complete and correct implementation of ERC2612, including the `DOMAIN_SEPARATOR()` function."
      ],
      "detection_strategy": "Check for issues related to fungible : erc20.",
      "main_category": "Token",
      "num_checklist_items": 16
    },
    "non_fungible_erc7211155": {
      "description": "Issues related to Non-fungible : ERC721/1155",
      "examples": [
        "How are the minting and transfer implemented?",
        "Is the contract safe from reentrancy attack?",
        "Is the OpenZeppelin implementation of ERC721 and ERC1155 safeguarded against reentrancy attacks, especially in the `safeTransferFrom` functions?",
        "Is it possible to steal NFT abusing his approval?",
        "Does the ERC721/1155 contract correctly implement supportsInterface?"
      ],
      "common_patterns": [
        "Use the supportsInterface method to check for and support interfaces of both ERC1155 and ERC721 with",
        "Ensure that the contract verifies the `msg.sender` is actually the owner.",
        "Use the checks-effects-interactions pattern and implement reentrancy guards to prevent potential ree",
        "Implement the supportsInterface function to return true for ERC721 and ERC1155 token types, ensuring"
      ],
      "detection_strategy": "Check for issues related to non-fungible : erc721/1155.",
      "main_category": "Token",
      "num_checklist_items": 8
    }
  }
}