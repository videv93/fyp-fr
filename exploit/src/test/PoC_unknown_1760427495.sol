// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IVulnerableContract {
    function adjustDailyClaimLimit(
        uint256 by,
        bool increaseClaimLimit
    ) external;

    function dailyClaimLimit() external view returns (uint256);

    function owner() external view returns (address);
}

contract VulnerableContract is IVulnerableContract {
    uint256 public dailyClaimLimit;
    address public owner;

    constructor(uint256 _initialLimit) {
        dailyClaimLimit = _initialLimit;
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    function adjustDailyClaimLimit(
        uint256 by,
        bool increaseClaimLimit
    ) external onlyOwner {
        if (increaseClaimLimit) {
            dailyClaimLimit += by;
        } else {
            require(dailyClaimLimit >= by, "Underflow protection");
            dailyClaimLimit -= by;
        }
    }
}

contract SafeContract is IVulnerableContract {
    uint256 public dailyClaimLimit;
    address public owner;
    uint256 public constant MAX_LIMIT = 1000 ether;
    uint256 public constant MIN_LIMIT = 10 ether;

    constructor(uint256 _initialLimit) {
        require(
            _initialLimit >= MIN_LIMIT && _initialLimit <= MAX_LIMIT,
            "Invalid initial limit"
        );
        dailyClaimLimit = _initialLimit;
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    function adjustDailyClaimLimit(
        uint256 by,
        bool increaseClaimLimit
    ) external onlyOwner {
        if (increaseClaimLimit) {
            require(dailyClaimLimit + by <= MAX_LIMIT, "Exceeds max limit");
            dailyClaimLimit += by;
        } else {
            require(dailyClaimLimit >= by, "Cannot reduce below zero");
            require(dailyClaimLimit - by >= MIN_LIMIT, "Below min limit");
            dailyClaimLimit -= by;
        }
    }
}

contract TestUnboundedLimitAdjustment is Test {
    IVulnerableContract vulnerable;
    IVulnerableContract safe;

    function setUp() public {
        vulnerable = new VulnerableContract(100 ether);
        safe = new SafeContract(100 ether);
    }

    function testExploit() public {
        vulnerable.adjustDailyClaimLimit(1000 ether, true);
        vm.startPrank(vulnerable.owner());
        assertEq(vulnerable.dailyClaimLimit(), 1100 ether);

        vulnerable.adjustDailyClaimLimit(200 ether, false);
        assertEq(vulnerable.dailyClaimLimit(), 900 ether);
        vm.stopPrank();

        vm.startPrank(safe.owner());
        vm.expectRevert("Exceeds max limit");
        safe.adjustDailyClaimLimit(1000 ether, true);

        vm.expectRevert("Below min limit");
        safe.adjustDailyClaimLimit(95 ether, false);

        safe.adjustDailyClaimLimit(50 ether, false);
        assertEq(safe.dailyClaimLimit(), 50 ether);
        vm.stopPrank();
    }
}

